"use strict";(globalThis.webpackChunk_orca_so_whirlpools_docs=globalThis.webpackChunk_orca_so_whirlpools_docs||[]).push([[714],{1184:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var i=t(4041);const s={},a=i.createContext(s);function r(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:n},e.children)}},1732:(e,n,t)=>{t.d(n,{A:()=>_});var i=t(4041),s=t(4357),a=t(7473),r=t(1034),o=t(6090),l=t(3351),c=t(6703),d=t(6004),u=t(6843);function p(e){return i.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,i.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function h(e){const{values:n,children:t}=e;return(0,i.useMemo)(()=>{const e=n??function(e){return p(e).map(({props:{value:e,label:n,attributes:t,default:i}})=>({value:e,label:n,attributes:t,default:i}))}(t);return function(e){const n=(0,d.XI)(e,(e,n)=>e.value===n.value);if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[n,t])}function m({value:e,tabValues:n}){return n.some(n=>n.value===e)}function g({queryString:e=!1,groupId:n}){const t=(0,o.W6)(),s=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,c.aZ)(s),(0,i.useCallback)(e=>{if(!s)return;const n=new URLSearchParams(t.location.search);n.set(s,e),t.replace({...t.location,search:n.toString()})},[s,t])]}function f(e){const{defaultValue:n,queryString:t=!1,groupId:s}=e,a=h(e),[r,o]=(0,i.useState)(()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!m({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const t=n.find(e=>e.default)??n[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:a})),[c,d]=g({queryString:t,groupId:s}),[p,f]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[t,s]=(0,u.Dv)(n);return[t,(0,i.useCallback)(e=>{n&&s.set(e)},[n,s])]}({groupId:s}),x=(()=>{const e=c??p;return m({value:e,tabValues:a})?e:null})();(0,l.A)(()=>{x&&o(x)},[x]);return{selectedValue:r,selectValue:(0,i.useCallback)(e=>{if(!m({value:e,tabValues:a}))throw new Error(`Can't select invalid tab value=${e}`);o(e),d(e),f(e)},[d,f,a]),tabValues:a}}var x=t(213);const y={tabList:"tabList_M0Dn",tabItem:"tabItem_ysIP"};var j=t(1085);function b({className:e,block:n,selectedValue:t,selectValue:i,tabValues:a}){const o=[],{blockElementScrollPositionUntilNextRender:l}=(0,r.a_)(),c=e=>{const n=e.currentTarget,s=o.indexOf(n),r=a[s].value;r!==t&&(l(n),i(r))},d=e=>{let n=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const t=o.indexOf(e.currentTarget)+1;n=o[t]??o[0];break}case"ArrowLeft":{const t=o.indexOf(e.currentTarget)-1;n=o[t]??o[o.length-1];break}}n?.focus()};return(0,j.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":n},e),children:a.map(({value:e,label:n,attributes:i})=>(0,j.jsx)("li",{role:"tab",tabIndex:t===e?0:-1,"aria-selected":t===e,ref:e=>{o.push(e)},onKeyDown:d,onClick:c,...i,className:(0,s.A)("tabs__item",y.tabItem,i?.className,{"tabs__item--active":t===e}),children:n??e},e))})}function v({lazy:e,children:n,selectedValue:t}){const a=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=a.find(e=>e.props.value===t);return e?(0,i.cloneElement)(e,{className:(0,s.A)("margin-top--md",e.props.className)}):null}return(0,j.jsx)("div",{className:"margin-top--md",children:a.map((e,n)=>(0,i.cloneElement)(e,{key:n,hidden:e.props.value!==t}))})}function w(e){const n=f(e);return(0,j.jsxs)("div",{className:(0,s.A)(a.G.tabs.container,"tabs-container",y.tabList),children:[(0,j.jsx)(b,{...n,...e}),(0,j.jsx)(v,{...n,...e})]})}function _(e){const n=(0,x.A)();return(0,j.jsx)(w,{...e,children:p(e.children)},String(n))}},3759:(e,n,t)=>{t.d(n,{A:()=>r});t(4041);var i=t(4357);const s={tabItem:"tabItem_OMyP"};var a=t(1085);function r({children:e,hidden:n,className:t}){return(0,a.jsx)("div",{role:"tabpanel",className:(0,i.A)(s.tabItem,t),hidden:n,children:e})}},8282:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>d,default:()=>m,frontMatter:()=>c,metadata:()=>i,toc:()=>p});const i=JSON.parse('{"id":"SDKs/Send Transaction","title":"Sending and Landing Transactions","description":"In this guide, we\'ll explore how to send transactions to the Solana blockchain for any Solana project. We\'ll cover two approaches:","source":"@site/docs/03-SDKs/06-Send Transaction.mdx","sourceDirName":"03-SDKs","slug":"/SDKs/Send Transaction","permalink":"/SDKs/Send Transaction","draft":false,"unlisted":false,"editUrl":"https://github.com/orca-so/whirlpools/tree/main/docs/whirlpool/docs/03-SDKs/06-Send Transaction.mdx","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_label":"Send Transactions","hide_table_of_contents":true},"sidebar":"sidebar","previous":{"title":"Trade","permalink":"/SDKs/Trade"},"next":{"title":"Utilities","permalink":"/SDKs/Utilities"}}');var s=t(1085),a=t(1184),r=t(8335),o=t(1732),l=t(3759);const c={sidebar_label:"Send Transactions",hide_table_of_contents:!0},d="Sending and Landing Transactions",u={},p=[{value:"The Easy Way: Using <code>tx-sender</code>",id:"the-easy-way-using-tx-sender",level:2},{value:"Installation",id:"installation",level:3},{value:"Usage",id:"usage",level:3},{value:"Configuration Options",id:"configuration-options",level:3},{value:"Default Settings",id:"default-settings",level:4},{value:"Priority Fee Configuration",id:"priority-fee-configuration",level:4},{value:"Understanding Dynamic Fees and Percentiles",id:"understanding-dynamic-fees-and-percentiles",level:5},{value:"Jito Tip Configuration",id:"jito-tip-configuration",level:4},{value:"Understanding Jito Tips and Dynamic Pricing",id:"understanding-jito-tips-and-dynamic-pricing",level:5},{value:"Compute Unit Configuration",id:"compute-unit-configuration",level:4},{value:"How Compute Unit Estimation Works",id:"how-compute-unit-estimation-works",level:5},{value:"RPC Configuration",id:"rpc-configuration",level:4},{value:"Example: Comprehensive Configuration",id:"example-comprehensive-configuration",level:4},{value:"The Manual Way: Using Solana SDKs Directly",id:"the-manual-way-using-solana-sdks-directly",level:2},{value:"Code Overview",id:"code-overview",level:2},{value:"1. Dependencies",id:"1-dependencies",level:3},{value:"2. Create Transaction Message From Instructions",id:"2-create-transaction-message-from-instructions",level:3},{value:"3. Estimating Compute Unit Limit and Prioritization Fee",id:"3-estimating-compute-unit-limit-and-prioritization-fee",level:3},{value:"4. Sign and Submit Transaction",id:"4-sign-and-submit-transaction",level:3},{value:"Handling transactions with Wallets in web apps.",id:"handling-transactions-with-wallets-in-web-apps",level:2},{value:"Creating Noop Signers",id:"creating-noop-signers",level:4},{value:"Prioritization Fees",id:"prioritization-fees",level:4},{value:"Additional Improvements for Landing Transactions",id:"additional-improvements-for-landing-transactions",level:2},{value:"Composing your own Transaction",id:"composing-your-own-transaction",level:2},{value:"Whirlpools Instruction Set",id:"whirlpools-instruction-set",level:3},{value:"Add priority fees, compute unit limits, and jito tips",id:"add-priority-fees-compute-unit-limits-and-jito-tips",level:3}];function h(e){const n={a:"a",annotation:"annotation",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",msup:"msup",mtext:"mtext",ol:"ol",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"sending-and-landing-transactions",children:"Sending and Landing Transactions"})}),"\n",(0,s.jsxs)(o.A,{groupId:"sdk-type",children:[(0,s.jsxs)(l.A,{value:"rust-ts-kit",label:"Rust & Typescript Kit",children:[(0,s.jsx)(n.p,{children:"In this guide, we'll explore how to send transactions to the Solana blockchain for any Solana project. We'll cover two approaches:"}),(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Using the simplified ",(0,s.jsx)(n.code,{children:"tx-sender"})," library - a lightweight solution that works with any Solana project"]}),"\n",(0,s.jsx)(n.li,{children:"The manual approach using Solana's native SDKs directly"}),"\n"]}),(0,s.jsxs)(n.h2,{id:"the-easy-way-using-tx-sender",children:["The Easy Way: Using ",(0,s.jsx)(n.code,{children:"tx-sender"})]}),(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"tx-sender"})," library is a lightweight package designed to simplify transaction building and sending in Solana. It handles all the complex aspects like priority fees, Jito tips, compute unit estimation, and retry logic automatically."]}),(0,s.jsx)(n.h3,{id:"installation",children:"Installation"}),(0,s.jsxs)(o.A,{groupId:"programming-languages",children:[(0,s.jsx)(l.A,{value:"rust",label:"Rust",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",metastring:'title="Cargo.toml"',children:'[dependencies]\norca_tx_sender = { version = "^3.0.0" }\n'})})}),(0,s.jsx)(l.A,{value:"ts-kit",label:"Typescript Kit",default:!0,children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:'title="package.json"',children:'"dependencies": {\n  "@orca-so/tx-sender": "^3.0.0"\n},\n'})})})]}),(0,s.jsx)(n.h3,{id:"usage",children:"Usage"}),(0,s.jsxs)(o.A,{groupId:"programming-languages",children:[(0,s.jsx)(l.A,{value:"rust",label:"Rust",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="main.rs"',children:'use orca_tx_sender::{\n    build_and_send_transaction,\n    set_rpc, get_rpc_client\n};\nuse solana_sdk::signature::Signer;\nuse solana_sdk::commitment_config::CommitmentLevel;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Initialize RPC configuration (required!)\n    set_rpc("https://api.mainnet-beta.solana.com").await?;\n\n    // Get instructions from Whirlpools SDK\n    let instructions_result = // your whirlpool instructions here\n\n    // Some instructions may require additional signers\n    let mut signers: Vec<&dyn Signer> = vec![&wallet];\n    signers.extend(instructions_result.additional_signers.iter().map(|kp| kp as &dyn Signer));            \n    \n    // Build and send transaction\n    let signature = build_and_send_transaction(\n        instructions_result.instructions,\n        &signers, // signers array including your wallet and any additional signers\n        Some(CommitmentLevel::Confirmed),\n        None, // No address lookup tables\n    ).await?;\n\n    println!("Transaction sent: {}", signature);\n    Ok(())\n}\n'})})}),(0,s.jsx)(l.A,{value:"ts-kit",label:"Typescript Kit",default:!0,children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",metastring:'title="sendTransaction.ts"',children:'import {\n  setRpc,\n  setPriorityFeeSetting,\n  setJitoTipSetting,\n  buildAndSendTransaction\n} from "@orca-so/tx-sender";\nimport { createSignerFromKeypair } from "@solana/kit";\n\n// Initialize RPC connection (required)\nawait setRpc("https://api.mainnet-beta.solana.com");\n\n// Get instructions from Whirlpools SDK\nconst { instructions } = // your whirlpool instructions here\n\n// Build and send transaction with default fee settings\nconst signature = await buildAndSendTransaction(\n  instructions,\n  wallet // your wallet signer\n);\n\nconsole.log(`Transaction confirmed: ${signature}`);\n'})})})]}),(0,s.jsx)(n.h3,{id:"configuration-options",children:"Configuration Options"}),(0,s.jsx)(n.p,{children:"The tx-sender library provides flexible configuration options to optimize your transaction sending strategy. Let's break these down in detail:"}),(0,s.jsx)(n.h4,{id:"default-settings",children:"Default Settings"}),(0,s.jsx)(n.p,{children:"By default, tx-sender uses the following configuration:"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Priority Fees"}),": Dynamic pricing with a max cap of 0.004 SOL (4,000,000 lamports)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Jito Tips"}),": Dynamic pricing with a max cap of 0.004 SOL (4,000,000 lamports)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Compute Unit Margin"}),": 1.1x multiplier for compute unit calculation (10% margin)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Jito Block Engine URL"}),": ",(0,s.jsx)(n.code,{children:"https://bundles.jito.wtf"})]}),"\n"]}),(0,s.jsx)(n.h4,{id:"priority-fee-configuration",children:"Priority Fee Configuration"}),(0,s.jsx)(n.p,{children:"Priority fees incentivize validators to include your transaction in blocks. The tx-sender library supports three priority fee strategies:"}),(0,s.jsx)(n.h5,{id:"understanding-dynamic-fees-and-percentiles",children:"Understanding Dynamic Fees and Percentiles"}),(0,s.jsx)(n.p,{children:'When using the "dynamic" fee strategy, tx-sender automatically analyzes recent network conditions to determine an appropriate fee. The system works by:'}),(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Calling the ",(0,s.jsx)(n.code,{children:"getRecentPrioritizationFees"})," RPC method, which returns data about fees from the last 150 blocks"]}),"\n",(0,s.jsx)(n.li,{children:"Sorting these fees from lowest to highest"}),"\n",(0,s.jsx)(n.li,{children:"Selecting a specific percentile from this data"}),"\n"]}),(0,s.jsx)(n.p,{children:"The tx-sender library allows capping these dynamic fees at a maximum amount to prevent excessive spending during extreme network conditions."}),(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": The tx-sender library automatically filters out zero-fee transactions before calculating percentiles. This ensures that during periods of low network activity when many blocks have zero fees, your transaction still has an appropriate non-zero fee to improve landing probability."]}),"\n"]}),(0,s.jsxs)(o.A,{groupId:"programming-languages",children:[(0,s.jsx)(l.A,{value:"rust",label:"Rust",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// 1. Dynamic fees - automatically adjusts based on network conditions\nset_priority_fee_strategy(PriorityFeeStrategy::Dynamic {\n    percentile: Percentile::P75, // Options: P25, P50, P75, P95, P99\n    max_lamports: 5_000_000,     // Optional: Cap at 0.005 SOL (default: 4,000,000)\n})?;\n\n// 2. Exact fees - specify an exact amount\nset_priority_fee_strategy(PriorityFeeStrategy::Exact(10_000))?; // Exactly 0.00001 SOL\n\n// 3. No priority fees\nset_priority_fee_strategy(PriorityFeeStrategy::Disabled)?;\n"})})}),(0,s.jsx)(l.A,{value:"ts-kit",label:"Typescript Kit",default:!0,children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// 1. Dynamic fees - automatically adjusts based on network conditions\nsetPriorityFeeSetting({\n  type: "dynamic",\n  maxCapLamports: BigInt(5_000_000), // Optional: Cap at 0.005 SOL (default: 4,000,000)\n});\n\n// 2. Exact fees - specify an exact amount\nsetPriorityFeeSetting({\n  type: "exact",\n  amountLamports: BigInt(10_000), // Exactly 0.00001 SOL\n});\n\n// 3. No priority fees\nsetPriorityFeeSetting({\n  type: "none",\n});\n\n// Set a specific priority fee percentile (applicable for dynamic fees)\n// Available values: "25", "50", "75", "95", "99"\nsetPriorityFeePercentile("75"); // Use 75th percentile (default: "50")\n'})})})]}),(0,s.jsx)(n.h4,{id:"jito-tip-configuration",children:"Jito Tip Configuration"}),(0,s.jsx)(n.p,{children:"Jito tips are additional fees that go to Jito MEV (Maximal Extractable Value) validators, who represent approximately 85% of Solana's validator stake. These tips can improve transaction landing probability even further than regular priority fees."}),(0,s.jsx)(n.h5,{id:"understanding-jito-tips-and-dynamic-pricing",children:"Understanding Jito Tips and Dynamic Pricing"}),(0,s.jsx)(n.p,{children:"Jito tips work similarly to priority fees but are specifically for Jito validators. When using dynamic Jito tips:"}),(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"The percentile system works the same way as with priority fees - selecting from recent fee data"}),"\n",(0,s.jsx)(n.li,{children:'Jito offers an additional option: "50ema" (Exponential Moving Average), which smooths out fee spikes by using a weighted average'}),"\n",(0,s.jsx)(n.li,{children:"Jito tips are sent directly to the Jito block engine rather than through the regular fee mechanism"}),"\n"]}),(0,s.jsx)(n.p,{children:"Using Jito tips is particularly effective because:"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Jito validators account for about 85% of Solana's stake weight"}),"\n",(0,s.jsx)(n.li,{children:"They use a specialized searching algorithm to look for higher-tipped transactions"}),"\n",(0,s.jsx)(n.li,{children:"During congestion, Jito validators can help your transaction land faster"}),"\n"]}),(0,s.jsx)(n.p,{children:"Like priority fees, Jito tips can be capped to prevent excessive spending. The default cap is 4,000,000 lamports (0.004 SOL)."}),(0,s.jsxs)(o.A,{groupId:"programming-languages",children:[(0,s.jsx)(l.A,{value:"rust",label:"Rust",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'// 1. Dynamic Jito tips\nset_jito_fee_strategy(JitoFeeStrategy::Dynamic {\n    percentile: JitoPercentile::P50Ema, // P25, P50, P75, P95, P99, P50Ema\n    max_lamports: 3_000_000,           // Optional: Cap at 0.003 SOL\n})?;\n\n// 2. Exact Jito tip\nset_jito_fee_strategy(JitoFeeStrategy::Exact(20_000))?; // Exactly 0.00002 SOL\n\n// 3. No Jito tips\nset_jito_fee_strategy(JitoFeeStrategy::Disabled)?;\n\n// Set custom Jito block engine URL (defaults to "https://bundles.jito.wtf")\nset_jito_block_engine_url("https://your-jito-service.com")?;\n'})})}),(0,s.jsx)(l.A,{value:"ts-kit",label:"Typescript Kit",default:!0,children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// 1. Dynamic Jito tips\nsetJitoTipSetting({\n  type: "dynamic",\n  maxCapLamports: BigInt(3_000_000), // Optional: Cap at 0.003 SOL (default: 4,000,000)\n});\n\n// 2. Exact Jito tip\nsetJitoTipSetting({\n  type: "exact",\n  amountLamports: BigInt(20_000), // Exactly 0.00002 SOL\n});\n\n// 3. No Jito tips\nsetJitoTipSetting({\n  type: "none",\n});\n\n// Set a specific Jito fee percentile or use EMA\n// Available values: "25", "50", "75", "95", "99", "50ema"\nsetJitoFeePercentile("50ema"); // Use 50th percentile exponential moving average\n\n// Set custom Jito block engine URL (defaults to "https://bundles.jito.wtf")\nsetJitoBlockEngineUrl("https://your-jito-service.com");\n'})})})]}),(0,s.jsx)(n.h4,{id:"compute-unit-configuration",children:"Compute Unit Configuration"}),(0,s.jsx)(n.p,{children:"The compute units represent the computational resources your transaction requires. The margin multiplier adds extra units as a safety buffer to prevent transaction failures."}),(0,s.jsx)(n.h5,{id:"how-compute-unit-estimation-works",children:"How Compute Unit Estimation Works"}),(0,s.jsx)(n.p,{children:"When sending a transaction, tx-sender performs these steps to optimize compute unit usage:"}),(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"First, it simulates your transaction on the RPC to estimate the required compute units"}),"\n",(0,s.jsx)(n.li,{children:"Then, it applies the margin multiplier to add a safety buffer (default is 1.1, or 10% extra)"}),"\n",(0,s.jsx)(n.li,{children:"Finally, it sets a compute unit limit instruction at the beginning of your transaction"}),"\n"]}),(0,s.jsx)(n.p,{children:"This process ensures that your transaction:"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Has enough compute units to complete execution"}),"\n",(0,s.jsx)(n.li,{children:"Doesn't allocate unnecessarily high compute units (which would cost more in fees)"}),"\n",(0,s.jsx)(n.li,{children:"Has a safety margin to account for differences between simulation and actual execution"}),"\n"]}),(0,s.jsx)(n.p,{children:"Setting an appropriate margin is important because:"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'Too low (close to 1.0): Transaction might fail with "out of compute units" error if network conditions change'}),"\n",(0,s.jsx)(n.li,{children:"Too high (over 1.5): Transactions that request higher compute units get lower priority for the same prioritization fee. Higher compute units signal to validators that your transaction will use more resources."}),"\n"]}),(0,s.jsx)(n.p,{children:"For most transactions, a value between 1.1 and 1.2 (10-20% margin) is appropriate. For complex or unpredictable transactions, you might want to use a higher value like 1.3 or 1.4."}),(0,s.jsxs)(o.A,{groupId:"programming-languages",children:[(0,s.jsx)(l.A,{value:"rust",label:"Rust",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// Values typically range from 1.0 (no margin) to 2.0 (100% extra margin)\n// Default is 1.1 (10% margin)\nset_compute_unit_margin_multiplier(1.2)?; // 20% margin\n"})})}),(0,s.jsx)(l.A,{value:"ts-kit",label:"Typescript Kit",default:!0,children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"// Values typically range from 1.0 (no margin) to 2.0 (100% extra margin)\n// Default is 1.1 (10% margin)\nsetComputeUnitMarginMultiplier(1.2); // 20% margin for compute units\n"})})})]}),(0,s.jsx)(n.h4,{id:"rpc-configuration",children:"RPC Configuration"}),(0,s.jsxs)(o.A,{groupId:"programming-languages",children:[(0,s.jsx)(l.A,{value:"rust",label:"Rust",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'// Basic RPC configuration\nset_rpc("https://api.mainnet-beta.solana.com").await?;\n// Get the configured RPC client for other operations\nlet client = get_rpc_client()?;\n'})})}),(0,s.jsx)(l.A,{value:"ts-kit",label:"Typescript Kit",default:!0,children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// Basic RPC configuration\nawait setRpc("https://api.mainnet-beta.solana.com");\n// For RPC providers that support percentile-based priority fees (e.g., Triton)\nawait setRpc("https://triton.rpcpool.com/some_endpoint", true);\n'})})})]}),(0,s.jsx)(n.h4,{id:"example-comprehensive-configuration",children:"Example: Comprehensive Configuration"}),(0,s.jsx)(n.p,{children:"Here's an example of a complete configuration setup:"}),(0,s.jsxs)(o.A,{groupId:"programming-languages",children:[(0,s.jsx)(l.A,{value:"rust",label:"Rust",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use orca_tx_sender::{\n    build_and_send_transaction,\n    PriorityFeeStrategy, JitoFeeStrategy,\n    Percentile, JitoPercentile,\n    set_priority_fee_strategy, set_jito_fee_strategy,\n    set_compute_unit_margin_multiplier, set_jito_block_engine_url,\n    set_rpc, get_rpc_client\n};\nuse solana_sdk::commitment_config::CommitmentLevel;\n\n// 1. Set up RPC connection\nset_rpc("https://api.mainnet-beta.solana.com").await?;\n\n// 2. Configure priority fees\nset_priority_fee_strategy(PriorityFeeStrategy::Dynamic {\n    percentile: Percentile::P75,\n    max_lamports: 5_000_000, // 0.005 SOL\n})?;\n\n// 3. Configure Jito tips\nset_jito_fee_strategy(JitoFeeStrategy::Dynamic {\n    percentile: JitoPercentile::P50Ema,\n    max_lamports: 3_000_000, // 0.003 SOL\n})?;\n\n// 4. Set compute unit margin\nset_compute_unit_margin_multiplier(1.2)?;\n\n// 5. Optional: Custom Jito endpoint\nset_jito_block_engine_url("https://bundles.jito.wtf")?;\n\n// 6. Send transaction with configured settings\nlet signature = build_and_send_transaction(\n    instructions,\n    &[&wallet],\n    Some(CommitmentLevel::Confirmed),\n    None\n).await?;\n'})})}),(0,s.jsx)(l.A,{value:"ts-kit",label:"Typescript Kit",default:!0,children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'import {\n  setRpc,\n  setPriorityFeeSetting,\n  setPriorityFeePercentile,\n  setJitoTipSetting,\n  setJitoFeePercentile,\n  setComputeUnitMarginMultiplier,\n  setJitoBlockEngineUrl,\n  buildAndSendTransaction\n} from "@orca-so/tx-sender";\n\n// 1. Set up RPC connection\nawait setRpc("https://api.mainnet-beta.solana.com");\n\n// 2. Configure priority fees\nsetPriorityFeeSetting({\n  type: "dynamic",\n  maxCapLamports: BigInt(5_000_000), // 0.005 SOL\n});\nsetPriorityFeePercentile("75");\n\n// 3. Configure Jito tips\nsetJitoTipSetting({\n  type: "dynamic",\n  maxCapLamports: BigInt(3_000_000), // 0.003 SOL\n});\nsetJitoFeePercentile("50ema");\n\n// 4. Set compute unit margin\nsetComputeUnitMarginMultiplier(1.2);\n\n// 5. Optional: Custom Jito endpoint\nsetJitoBlockEngineUrl("https://bundles.jito.wtf");\n\n// 6. Send transaction with configured settings\nconst signature = await buildAndSendTransaction(\n  instructions,\n  wallet\n);\n'})})})]}),(0,s.jsx)(n.h2,{id:"the-manual-way-using-solana-sdks-directly",children:"The Manual Way: Using Solana SDKs Directly"}),(0,s.jsx)(n.p,{children:"In this section, we'll explore how to send the instructions using the Solana SDK directly - both in Typescript and Rust. We'll cover the following key topics:"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Client-side retry"}),"\n",(0,s.jsx)(n.li,{children:"Prioritization fees"}),"\n",(0,s.jsx)(n.li,{children:"Compute budget estimation"}),"\n"]}),(0,s.jsx)(n.p,{children:"We also cover key considerations for sending transactions in web applications with wallet extensions, along with additional steps to improve transaction landing."}),(0,s.jsx)(n.h2,{id:"code-overview",children:"Code Overview"}),(0,s.jsx)(n.h3,{id:"1-dependencies",children:"1. Dependencies"}),(0,s.jsx)(n.p,{children:"Let's start by importing the necessary dependencies from Solana's SDKs."}),(0,s.jsxs)(o.A,{groupId:"programming-languages",children:[(0,s.jsxs)(l.A,{value:"rust",label:"Rust",children:[(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",metastring:'title="Cargo.toml"',children:'serde_json = { version = "^1.0" }\nsolana-client = { version = "^1.18" }\nsolana-sdk = { version = "^1.18" }\ntokio = { version = "^1.41.1" }\n'})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="main.rs"',children:"use solana_client::nonblocking::rpc_client::RpcClient;\nuse solana_client::rpc_config::RpcSendTransactionConfig;\nuse solana_sdk::commitment_config::CommitmentLevel;\nuse solana_sdk::compute_budget::ComputeBudgetInstruction;\nuse solana_sdk::message::Message;\nuse solana_sdk::pubkey::Pubkey;\nuse solana_sdk::signature::Signature;\nuse solana_sdk::transaction::Transaction;\nuse solana_sdk::{signature::Keypair, signer::Signer};\nuse std::fs;\nuse std::str::FromStr;\nuse tokio::time::{sleep, Duration, Instant};\n"})})]}),(0,s.jsxs)(l.A,{value:"ts-kit",label:"Typescript Kit",default:!0,children:[(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:'title="package.json"',children:'"dependencies": {\n  "@solana-program/compute-budget": "^0.6.1",\n  "@solana/kit": "^2.1.0",\n},\n'})}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",metastring:'title="sendTransaction.ts"',children:"import {\n  createSolanaRpc,\n  address,\n  pipe,\n  createTransactionMessage,\n  setTransactionMessageFeePayer,\n  setTransactionMessageLifetimeUsingBlockhash,\n  appendTransactionMessageInstructions,\n  prependTransactionMessageInstructions,\n  signTransactionMessageWithSigners,\n  getComputeUnitEstimateForTransactionMessageFactory,\n  getBase64EncodedWireTransaction,\n  setTransactionMessageFeePayerSigner\n} from '@solana/kit';\nimport {\n  getSetComputeUnitLimitInstruction,\n  getSetComputeUnitPriceInstruction\n} from '@solana-program/compute-budget';\n"})})]})]}),(0,s.jsx)(n.h3,{id:"2-create-transaction-message-from-instructions",children:"2. Create Transaction Message From Instructions"}),(0,s.jsx)(n.p,{children:"To send a transaction on Solana, you need to include a blockhash to the transaction. A blockhash acts as a timestamp and ensures the transaction has a limited lifetime. Validators use the blockhash to verify the recency of a transaction before including it in a block. A transaction referencing a blockhash is only valid for 150 blocks (~1-2 minutes, depending on slot time). After that, the blockhash expires, and the transaction will be rejected."}),(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Durable Nonces"}),": In some cases, you might need a transaction to remain valid for longer than the typical blockhash lifespan, such as when scheduling future payments or collecting multi-signature approvals over time. In that case, you can use ",(0,s.jsx)(n.a,{href:"https://solana.com/developers/courses/offline-transactions/durable-nonces",children:"durable nonces"})," to sign the transaction, which includes a nonce in place of a recent blockhash."]}),"\n"]}),(0,s.jsxs)(n.p,{children:["You also need to add the signers to the transactions. With Solana Kit, you can create instructions and add additional signers as ",(0,s.jsx)(n.code,{children:"TransactionSigner"})," to the instructions. The Typescript Whirlpools SDK leverages this functioanlity and appends all additional signers to the instructions for you. In Rust, this feautures is not available. Therefore, the Rust Whirlpools SDK may return ",(0,s.jsx)(n.code,{children:"instruction_result.additional_signers"})," if there are any, and you need to manually append them to the transaction."]}),(0,s.jsx)(n.p,{children:"Here's how the transaction message is created:"}),(0,s.jsxs)(o.A,{groupId:"programming-languages",children:[(0,s.jsx)(l.A,{value:"rust",label:"Rust",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="main.rs"',children:"#[tokio::main]\nasync fn main() {\n  // ...\n  let instructions_result = // get instructions from Whirlpools SDK\n  let message = Message::new(\n    &instructions_result.instructions,\n    Some(&wallet.pubkey()),\n  );\n  let mut signers: Vec<&dyn Signer> = vec![&wallet];\n  signers.extend(\n    instructions_result\n      .additional_signers\n      .iter()\n      .map(|kp| kp as &dyn Signer),\n  );\n  let recent_blockhash = rpc.get_latest_blockhash().await.unwrap();\n  let transaction = Transaction::new(&signers, message, recent_blockhash);\n  // ...\n}\n"})})}),(0,s.jsx)(l.A,{value:"ts-kit",label:"Typescript Kit",default:!0,children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",metastring:'title="sendTransaction.ts"',children:"const { instructions } = // get instructions from Whirlpools SDK\nconst latestBlockHash = await rpc.getLatestBlockhash().send();\nconst transactionMessage = await pipe(\n  createTransactionMessage({ version: 0}),\n  tx => setTransactionMessageFeePayer(wallet.address, tx),\n  tx => setTransactionMessageLifetimeUsingBlockhash(latestBlockHash.value, tx),\n  tx => appendTransactionMessageInstructions(instructions, tx)\n)\n"})})})]}),(0,s.jsx)(n.h3,{id:"3-estimating-compute-unit-limit-and-prioritization-fee",children:"3. Estimating Compute Unit Limit and Prioritization Fee"}),(0,s.jsx)(n.p,{children:"Before sending a transaction, it's important to set a compute unit limit and an appropriate prioritization fee."}),(0,s.jsx)(n.p,{children:"Transactions that request fewer compute units get high priority for the same amount of prioritization fee (which is defined per compute unit). Setting the compute units too low will result in a failed transaction."}),(0,s.jsx)(n.p,{children:"You can get an estimate of the compute units by simulating the transaction on the RPC. To avoid transaction failures caused by underestimating this limit, you can add an additional 100,000 compute units, but you can adjust this based on your own tests."}),(0,s.jsxs)(n.p,{children:["The prioritization fee per compute unit also incentivizes validators to prioritize your transaction, especially during times of network congestion. You can call the ",(0,s.jsx)(n.code,{children:"getRecentPrioritizationFees"})," RPC method to retrieve an array of 150 values, where each value represents the lowest priority fee paid for transactions that landed in each of the past 150 blocks. In this example, we sort that list and select the 50th percentile, but you can adjust this if needed. The prioritization fee is provided in micro-lamports per compute unit. The total priority fee in lamports you will pay is calculated as ",(0,s.jsxs)(n.span,{className:"katex",children:[(0,s.jsx)(n.span,{className:"katex-mathml",children:(0,s.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(n.semantics,{children:[(0,s.jsxs)(n.mrow,{children:[(0,s.jsx)(n.mo,{stretchy:"false",children:"("}),(0,s.jsx)(n.mtext,{children:"estimated\xa0compute\xa0units"}),(0,s.jsx)(n.mo,{children:"\u22c5"}),(0,s.jsx)(n.mtext,{children:"prioritization\xa0fee"}),(0,s.jsx)(n.mo,{stretchy:"false",children:")"}),(0,s.jsx)(n.mi,{mathvariant:"normal",children:"/"}),(0,s.jsxs)(n.msup,{children:[(0,s.jsx)(n.mn,{children:"10"}),(0,s.jsx)(n.mn,{children:"6"})]})]}),(0,s.jsx)(n.annotation,{encoding:"application/x-tex",children:"(\\text{estimated compute units} \\cdot \\text{prioritization fee}) / 10^6"})]})})}),(0,s.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.jsx)(n.span,{className:"mopen",children:"("}),(0,s.jsx)(n.span,{className:"mord text",children:(0,s.jsx)(n.span,{className:"mord",children:"estimated\xa0compute\xa0units"})}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,s.jsx)(n.span,{className:"mbin",children:"\u22c5"}),(0,s.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,s.jsxs)(n.span,{className:"base",children:[(0,s.jsx)(n.span,{className:"strut",style:{height:"1.0641em",verticalAlign:"-0.25em"}}),(0,s.jsx)(n.span,{className:"mord text",children:(0,s.jsx)(n.span,{className:"mord",children:"prioritization\xa0fee"})}),(0,s.jsx)(n.span,{className:"mclose",children:")"}),(0,s.jsx)(n.span,{className:"mord",children:"/1"}),(0,s.jsxs)(n.span,{className:"mord",children:[(0,s.jsx)(n.span,{className:"mord",children:"0"}),(0,s.jsx)(n.span,{className:"msupsub",children:(0,s.jsx)(n.span,{className:"vlist-t",children:(0,s.jsx)(n.span,{className:"vlist-r",children:(0,s.jsx)(n.span,{className:"vlist",style:{height:"0.8141em"},children:(0,s.jsxs)(n.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,s.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,s.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,s.jsx)(n.span,{className:"mord mtight",children:"6"})})]})})})})})]})]})]})]}),"."]}),(0,s.jsxs)(o.A,{groupId:"programming-languages",children:[(0,s.jsx)(l.A,{value:"rust",label:"Rust",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="main.rs"',children:"#[tokio::main]\nasync fn main() {\n  // ...\n  let simulated_transaction = rpc.simulate_transaction(&transaction).await.unwrap();\n\n  let mut all_instructions = vec![];\n  if let Some(units_consumed) = simulated_transaction.value.units_consumed {\n    let units_consumed_safe = units_consumed as u32 + 100_000;\n    let compute_limit_instruction =\n      ComputeBudgetInstruction::set_compute_unit_limit(units_consumed_safe);\n    all_instructions.push(compute_limit_instruction);\n\n    let prioritization_fees = rpc\n      .get_recent_prioritization_fees(&[whirlpool_address])\n      .await\n      .unwrap();\n    let mut prioritization_fees_array: Vec<u64> = prioritization_fees\n      .iter()\n      .map(|fee| fee.prioritization_fee)\n      .collect();\n    prioritization_fees_array.sort_unstable();\n    let prioritization_fee = prioritization_fees_array\n      .get(prioritization_fees_array.len() / 2)\n      .cloned();\n\n    if let Some(prioritization_fee) = prioritization_fee {\n      let priority_fee_instruction =\n        ComputeBudgetInstruction::set_compute_unit_price(prioritization_fee);\n      all_instructions.push(priority_fee_instruction);\n    }\n  }\n  // ...\n}\n"})})}),(0,s.jsx)(l.A,{value:"ts-kit",label:"Typescript Kit",default:!0,children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",metastring:'title="sendTransaction.ts"',children:"const getComputeUnitEstimateForTransactionMessage =\n  getComputeUnitEstimateForTransactionMessageFactory({\n    rpc\n  });\nconst computeUnitEstimate = await getComputeUnitEstimateForTransactionMessage(transactionMessage) + 100_000;\nconst medianPrioritizationFee = await rpc.getRecentPrioritizationFees()\n  .send()\n  .then(fees =>\n    fees\n      .map(fee => Number(fee.prioritizationFee))\n      .sort((a, b) => a - b)\n      [Math.floor(fees.length / 2)]\n  );\nconst transactionMessageWithComputeUnitInstructions = await prependTransactionMessageInstructions([\n  getSetComputeUnitLimitInstruction({ units: computeUnitEstimate }),\n  getSetComputeUnitPriceInstruction({ microLamports: medianPrioritizationFee })\n], transactionMessage);\n"})})})]}),(0,s.jsx)(n.h3,{id:"4-sign-and-submit-transaction",children:"4. Sign and Submit Transaction"}),(0,s.jsx)(n.p,{children:"Finally, the transaction needs to be signed, encoded, and submitted to the network. A client-side time-base retry mechanism ensures that the transaction is repeatedly sent until it is confirmed or the time runs out. We use a time-based loop, because we know that the lifetime of a transaction is 150 blocks, which on average takes about 79-80 seconds. The signing of the transactions is an idempotent operation and produces a transaction hash, which acts as the transaction ID. Since transactions can be added only once to the block chain, we can keep sending the transaction during the lifetime of the trnsaction."}),(0,s.jsxs)(n.p,{children:["You're probably wondering why we don't just use the widely used ",(0,s.jsx)(n.code,{children:"sendAndConfirm"})," method. This is because the retry mechanism of the ",(0,s.jsx)(n.code,{children:"sendAndConfirm"})," method is executed on the RPC. By default, RPC nodes will try to forward (rebroadcast) transactions to leaders every two seconds until either the transaction is finalized, or the transaction's blockhash expires. If the outstanding rebroadcast queue size is greater than 10,000 transaction, newly submitted transactions are dropped. This means that at times of congestion, your transaction might not even arrive at the RPC in the first place. Moreover, the ",(0,s.jsx)(n.code,{children:"confirmTransaction"})," RPC method that ",(0,s.jsx)(n.code,{children:"sendAndConfirm"})," calls is deprecated."]}),(0,s.jsxs)(o.A,{groupId:"programming-languages",children:[(0,s.jsx)(l.A,{value:"rust",label:"Rust",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="main.rs"',children:'#[tokio::main]\nasync fn main() {\n  // ...\n  all_instructions.extend(open_position_instructions.instructions);\n  let message = Message::new(&all_instructions, Some(&wallet.pubkey()));\n\n  let transaction = Transaction::new(&signers ,message , recent_blockhash);\n  let transaction_config = RpcSendTransactionConfig {\n    skip_preflight: true,\n    preflight_commitment: Some(CommitmentLevel::Confirmed),\n    max_retries: Some(0),\n    ..Default::default()\n  };\n\n  let start_time = Instant::now();\n  let timeout = Duration::from_secs(90);\n  let send_transaction_result = loop {\n    if start_time.elapsed() >= timeout {\n      break Err(Box::<dyn std::error::Error>::from("Transaction timed out"));\n    }\n    let transaction_start_time = Instant::now();\n\n    let signature: Signature = rpc\n      .send_transaction_with_config(&transaction, transaction_config)\n      .await\n      .unwrap();\n    let statuses = rpc\n      .get_signature_statuses(&[signature])\n      .await\n      .unwrap()\n      .value;\n\n    if let Some(status) = statuses[0].clone() {\n      break Ok((status, signature));\n    }\n\n    let elapsed_time = transaction_start_time.elapsed();\n    let remaining_time = Duration::from_millis(1000).saturating_sub(elapsed_time);\n    if remaining_time > Duration::ZERO {\n      sleep(remaining_time).await;\n    }\n  };\n\n  let signature = send_transaction_result.and_then(|(status, signature)| {\n    if let Some(err) = status.err {\n      Err(Box::new(err))\n    } else {\n      Ok(signature)\n    }\n  });\n  println!("Result: {:?}", signature);\n}\n'})})}),(0,s.jsx)(l.A,{value:"ts-kit",label:"Typescript Kit",default:!0,children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",metastring:'title="sendTransaction.ts"',children:"const signedTransaction = await signTransactionMessageWithSigners(transactionMessageWithComputeUnitInstructions)\nconst base64EncodedWireTransaction = getBase64EncodedWireTransaction(signedTransaction);\n\nconst timeoutMs = 90000;\nconst startTime = Date.now();\n\nwhile (Date.now() - startTime < timeoutMs) {\n  const transactionStartTime = Date.now();\n\n  const signature = await rpc.sendTransaction(base64EncodedWireTransaction, {\n    maxRetries: 0n,\n    skipPreflight: true,\n    encoding: 'base64'\n  }).send();\n\n  const statuses = await rpc.getSignatureStatuses([signature]).send();\n  if (statuses.value[0]) {\n    if (!statuses.value[0].err) {\n      console.log(`Transaction confirmed: ${signature}`);\n      break;\n    } else {\n      console.error(`Transaction failed: ${statuses.value[0].err.toString()}`);\n      break;\n    }\n  }\n\n  const elapsedTime = Date.now() - transactionStartTime;\n  const remainingTime = Math.max(0, 1000 - elapsedTime);\n  if (remainingTime > 0) {\n    await new Promise(resolve => setTimeout(resolve, remainingTime));\n  }\n}\n"})})})]}),(0,s.jsx)(n.h2,{id:"handling-transactions-with-wallets-in-web-apps",children:"Handling transactions with Wallets in web apps."}),(0,s.jsx)(n.h4,{id:"creating-noop-signers",children:"Creating Noop Signers"}),(0,s.jsxs)(n.p,{children:["When sending transactions from your web application, users need to sign the transaction using their wallet. Since the transaction needs to assembled beforehand, you can create a ",(0,s.jsx)(n.code,{children:"noopSigner"})," (no-operation signer) and add it to the instructions. This will act as a placeholder for you instructions, indicating that a given account is a signer and the signature wil be added later. After assembling the transaction you can pass it to the wallet extension. If the user signs, it will return a serialized transaction with the added signature."]}),(0,s.jsx)(n.h4,{id:"prioritization-fees",children:"Prioritization Fees"}),(0,s.jsx)(n.p,{children:"Some wallets will calculate and apply priority fees for your transactions, provided:"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The transaction does not already have signatures present."}),"\n",(0,s.jsx)(n.li,{children:"The transaction does not have existing compute-budget instructions."}),"\n",(0,s.jsx)(n.li,{children:"The transactions will still be less than the maximum transaction size fo 1232 bytes, after applying compute-budget instructions."}),"\n"]}),(0,s.jsx)(n.h2,{id:"additional-improvements-for-landing-transactions",children:"Additional Improvements for Landing Transactions"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"You could send your transaction to multiple RPC nodes at the same time, all within each iteration of the time-based loop."}),"\n",(0,s.jsxs)(n.li,{children:["At the time of writing, 85% of Solana validators are Jito validators. Jito validators happily accept an additional tip, in the form a SOL transfer, to prioritize a transaction. A good place to get familiarized with Jito is here: ",(0,s.jsx)(n.a,{href:"https://www.jito.network/blog/jito-solana-is-now-open-source/",children:"https://www.jito.network/blog/jito-solana-is-now-open-source/"})]}),"\n",(0,s.jsx)(n.li,{children:"Solana gives staked validators more reliable performance when sending transactions by routing them through prioritized connections. This mechanism is referred to as stake-weighted Quality of Service (swQoS). Validators can extend this service to RPC nodes, essentially giving staked connections to RPC nodes as if they were validators with that much stake in the network. RPC providers, like Helius and Titan, expose such peered RPC nodes to paid users, allowing users to send transactions to RPC nodes which use the validator's staked connections. From the RPC, the transaction is then sent over the staked connection with a lower likelihood of being delayed or dropped."}),"\n"]})]}),(0,s.jsxs)(l.A,{value:"ts-legacy",label:"Typescript Legacy",children:[(0,s.jsx)(n.h2,{id:"composing-your-own-transaction",children:"Composing your own Transaction"}),(0,s.jsx)(n.p,{children:"Use the TransactionBuilder class to construct and compose your own Transactions to perform actions on the Whirlpools contract."}),(0,s.jsx)(n.h3,{id:"whirlpools-instruction-set",children:"Whirlpools Instruction Set"}),(0,s.jsx)(r.A,{item:{type:"link",href:"https://dev.orca.so/legacy/classes/WhirlpoolIx.html",label:"Whirlpools Instruction Set",description:"https://dev.orca.so/legacy/classes/WhirlpoolIx.html"}}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const txBuilder = new TransactionBuilder(ctx.provider);\ntxBuilder.addInstruction(WhirlpoolIx.initializeConfigIx(ctx, configParams));\n...\ntxBuilder.addInstruction(otherIx).addSigner(otherSigner);\n...\nawait txBuilder.buildAndExecute();\n"})}),(0,s.jsxs)(n.p,{children:["Use to ",(0,s.jsx)(n.code,{children:"toTx"})," function if you only have one transaction to send out"]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const tx = toTx(ctx, WhirlpoolIx.initializeConfigIx(ctx.program, configParams));\nawait txBuilder.buildAndExecute();\n"})}),(0,s.jsx)(n.h3,{id:"add-priority-fees-compute-unit-limits-and-jito-tips",children:"Add priority fees, compute unit limits, and jito tips"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'await txBuilder.buildAndExecute({computeUnitBudget: "auto"});\n'})})]})]})]})}function m(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8335:(e,n,t)=>{t.d(n,{A:()=>w});var i=t(4041),s=t(4357),a=t(2436),r=t(8082),o=t(396);const l=["zero","one","two","few","many","other"];function c(e){return l.filter(n=>e.includes(n))}const d={locale:"en",pluralForms:c(["one","other"]),select:e=>1===e?"one":"other"};function u(){const{i18n:{currentLocale:e}}=(0,o.A)();return(0,i.useMemo)(()=>{try{return function(e){const n=new Intl.PluralRules(e);return{locale:e,pluralForms:c(n.resolvedOptions().pluralCategories),select:e=>n.select(e)}}(e)}catch(n){return console.error(`Failed to use Intl.PluralRules for locale "${e}".\nDocusaurus will fallback to the default (English) implementation.\nError: ${n.message}\n`),d}},[e])}function p(){const e=u();return{selectMessage:(n,t)=>function(e,n,t){const i=e.split("|");if(1===i.length)return i[0];i.length>t.pluralForms.length&&console.error(`For locale=${t.locale}, a maximum of ${t.pluralForms.length} plural forms are expected (${t.pluralForms.join(",")}), but the message contains ${i.length}: ${e}`);const s=t.select(n),a=t.pluralForms.indexOf(s);return i[Math.min(a,i.length-1)]}(t,n,e)}}var h=t(5436),m=t(9082),g=t(4441);const f={cardContainer:"cardContainer_S8oU",cardTitle:"cardTitle_HoSo",cardDescription:"cardDescription_c27F"};var x=t(1085);function y({href:e,children:n}){return(0,x.jsx)(a.A,{href:e,className:(0,s.A)("card padding--lg",f.cardContainer),children:n})}function j({href:e,icon:n,title:t,description:i}){return(0,x.jsxs)(y,{href:e,children:[(0,x.jsxs)(g.A,{as:"h2",className:(0,s.A)("text--truncate",f.cardTitle),title:t,children:[n," ",t]}),i&&(0,x.jsx)("p",{className:(0,s.A)("text--truncate",f.cardDescription),title:i,children:i})]})}function b({item:e}){const n=(0,r.Nr)(e),t=function(){const{selectMessage:e}=p();return n=>e(n,(0,m.T)({message:"1 item|{count} items",id:"theme.docs.DocCard.categoryDescription.plurals",description:"The default description for a category card in the generated index about how many items this category includes"},{count:n}))}();return n?(0,x.jsx)(j,{href:n,icon:"\ud83d\uddc3\ufe0f",title:e.label,description:e.description??t(e.items.length)}):null}function v({item:e}){const n=(0,h.A)(e.href)?"\ud83d\udcc4\ufe0f":"\ud83d\udd17",t=(0,r.cC)(e.docId??void 0);return(0,x.jsx)(j,{href:e.href,icon:n,title:e.label,description:e.description??t?.description})}function w({item:e}){switch(e.type){case"link":return(0,x.jsx)(v,{item:e});case"category":return(0,x.jsx)(b,{item:e});default:throw new Error(`unknown item type ${JSON.stringify(e)}`)}}}}]);