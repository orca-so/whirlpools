"use strict";(self.webpackChunk_orca_so_whirlpools_docs=self.webpackChunk_orca_so_whirlpools_docs||[]).push([[335],{9097:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>p,concentratedPoolNote:()=>w,concentratedPoolOpeningSteps:()=>x,contentTitle:()=>d,default:()=>v,frontMatter:()=>c,gettingStartedGuide:()=>m,introText:()=>h,metadata:()=>t,nextSteps:()=>f,positionsIntro:()=>u,splashPoolOpeningSteps:()=>y,toc:()=>k,usageExamples:()=>g});const t=JSON.parse('{"id":"SDKs/Position Management/Open Position","title":"Open Position","description":"- Splash Pools: Provide liquidity without specifying a price range. Ideal for those seeking a simple way to start providing liquidity.","source":"@site/docs/03-SDKs/04-Position Management/01-Open Position.mdx","sourceDirName":"03-SDKs/04-Position Management","slug":"/SDKs/Position Management/Open Position","permalink":"/SDKs/Position Management/Open Position","draft":false,"unlisted":false,"editUrl":"https://github.com/orca-so/whirlpools/tree/main/docs/whirlpool/docs/03-SDKs/04-Position Management/01-Open Position.mdx","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_label":"Open Position","hide_table_of_contents":true},"sidebar":"sidebar","previous":{"title":"Monitor Liquidity Pools","permalink":"/SDKs/Whirlpool Management/Monitor pools"},"next":{"title":"Adjust Liquidity","permalink":"/SDKs/Position Management/Adjust Liquidity"}}');var o=i(1085),s=i(1184),a=i(95),r=i(4435),l=i(8156);const c={sidebar_label:"Open Position",hide_table_of_contents:!0},d="Opening a Position",p={},h="\nOpening a position in liquidity pools on Orca is a fundamental step for providing liquidity and earning fees. In this guide, we'll explore how to open a position in both **Splash Pools** and **Concentrated Liquidity Pools**, their differences, and which approach is suitable for different use cases.\n",u="\n## 1. Introduction to Positions in Pools\nA position in a liquidity pool represents your contribution of liquidity, which allows traders to swap between tokens while you earn a share of the trading fees. When you open a position, you decide how much liquidity to add, and this liquidity can later be adjusted or removed.\n\n- **Splash Pools**: Provide liquidity without specifying a price range. Ideal for those seeking a simple way to start providing liquidity.\n\n- **Concentrated Liquidity Pools**: Allow you to provide liquidity within a specified price range, enabling higher capital efficiency but requiring more advanced management.\n\nUpon creation of the position, an NFT will be minted to represent ownership of the position. This NFT is used by the program to verify your ownership when adjusting liquidity, harvesting rewards, or closing the position. For more information, refer to [Tokenized Positions](../../../02-Architecture%20Overview/04-Tokenized%20Positions.md).\n\n> \u26a0\ufe0f **Risk of Divergence loss**: The ratio of Token A to Token B that you deposit as liquidity is determined by several factors, including the current price. As trades occur against the pool, the amounts of Token A and Token B in the pool \u2014 and in your position \u2014 will change, which affects the price of the tokens relative to each other. This can work to your advantage, but it may also result in the combined value of your tokens (including any earned fees and rewards) being lower than when you initially provided liquidity.\n",m="\n## 2. Getting Started Guide\nBefore opening a position, ensure you have completed the environment setup:\n- **RPC Setup**: Use a Solana RPC client to communicate with the blockchain.\n- **Wallet Creation**: Create a wallet to interact with the Solana network.\n- **Devnet Airdrop**: Fund your wallet with a Solana Devnet airdrop to cover transaction fees.\n\nFor more details, refer to our [Environment Setup Guide](../02-Environment%20Setup.mdx)\n",y="\n### Opening a Position in Splash Pools\n1. **Pool Address**: Provide the address of the Splash Pool where you want to open a position.\n2. **Liquidity Parameters**: Choose how you want to provide liquidity. You only need to provide one of these parameters, and the function will compute the others in the returned quote based on the current price of the pool:\n  - `liquidity`: Specify the liquidity value to provide.\n  - `tokenA`: Specify the amount of token A (first token in the pool).\n  - `tokenB`: Specify the amount of token B (second token in the pool).\n3. **Slippage Tolerance**: Set the maximum slippage tolerance (optional, defaults to 1%). Slippage refers to the difference between the expected price and the actual price at which the transaction is executed. A lower slippage tolerance reduces the risk of price changes during the transaction but may lead to failed transactions if the market moves too quickly.\n4. **Funder**: This will be your wallet, which will fund the transaction.\n5. **Create Instructions**: Use the appropriate function to generate the necessary instructions.\n",x="\n### Opening a Position in Concentrated Liquidity Pools\n1. **Pool Address**: Provide the address of the Concentrated Liquidity Pool where you want to open a position.\n2. **Liquidity Parameters**: Choose how you want to provide liquidity. You only need to provide one of these parameters, and the function will compute the others in the returned quote based on the price range and the current price of the pool:\n  - `liquidity`: Specify the liquidity value to provide.\n  - `tokenA`: Specify the amount of token A (first token in the pool).\n  - `tokenB`: Specify the amount of token B (second token in the pool).\n3. **Price Range**: Set the lower and upper bounds of the price range within which your liquidity will be active. The current price and the specified price range will influence the quote amounts. If the current price is in the middle of your price range, the ratio of token A to token B will reflect that price. However, if the current price is outside your range, you will only deposit one token, resulting in one-sided liquidity. Note that your position will only earn fees when the price falls within your selected price range, so it's important to choose a range where you expect the price to remain active.\n3. **Slippage Tolerance**: Set the maximum slippage tolerance (optional, defaults to 1%). Slippage refers to the difference between the expected token amounts and the actual amounts deposited into the liquidity pool. A lower slippage tolerance reduces the risk of depositing more tokens than expected but may lead to failed transactions if the market moves too quickly. For example, if you expect to deposit 100 units of Token A and 1,000 units of Token B, with a 1% slippage tolerance, the maximum amounts would be 101 Token A and 1,010 Token B.\n4. **Funder**: This can be your wallet, which will fund the pool initialization. If the funder is not specified, the default wallet will be used. You can configure the default wallet through the SDK.\n5. **Create Instructions**: Use the appropriate function to generate the necessary instructions.\n",w="\n> \u26a0\ufe0f You cannot use this function on Splash Pools, as this function is specifically for Concentrated Liquidity Pools.\n",g="\n## 3. Usage examples\n### Opening a Position in a Splash Pool\nSuppose you want to provide 1,000,000 tokens of Token A at a price of 0.0001 SOL. You will also need to provide 100 SOL as Token B to match the price. By using the SDK to open full range positions, you ensure that your liquidity is spread evenly across all price levels. This approach is ideal if you are launching a new token and want to facilitate easy swaps for traders.\n\n### Opening a Position in a Concentrated Liquidity Pool\nIf you want to maximize capital efficiency, you can open a position in a Concentrated Liquidity Pool. For example, if the current price is at 0.01 and you want to maximize profitability, you could use the SDK to deposit liquidity between the price range of 0.009 and 0.011. This approach allows you to focus your liquidity in a narrow range, making it more effective and potentially more profitable.\n",f="\n## Next Steps\nAfter opening a position, you can:\n- [Add or Remove Liquidity](03-Adjust%20Liquidity.mdx): Adjust the amount of liquidity in your position based on market conditions.\n- [Harvest Rewards](04-Harvest.mdx): Collect rewards and fees without closing the position.\n- [Monitor Performance](02-Fetch%20Positions.mdx): Track your position's performance and earned fees.\n- [Close Position](05-Close%20Position.mdx): When you decide to exit, close the position and withdraw the provided tokens along with any earned fees.\n",k=[{value:"Opening Position with Metadata",id:"opening-position-with-metadata",level:2},{value:"Initialize Tick Array accounts if needed",id:"initialize-tick-array-accounts-if-needed",level:2},{value:"Open Position with WhirlpoolClient",id:"open-position-with-whirlpoolclient",level:2},{value:"The Manual way",id:"the-manual-way",level:2},{value:"Determine position parameters",id:"determine-position-parameters",level:2},{value:"Common Errors",id:"common-errors",level:2}];function P(e){const n={a:"a",annotation:"annotation",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",math:"math",mn:"mn",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"opening-a-position",children:"Opening a Position"})}),"\n",(0,o.jsxs)(a.A,{groupId:"sdk-type",children:[(0,o.jsxs)(r.A,{value:"rust",label:"Rust",children:[(0,o.jsx)(l.oz,{children:h}),(0,o.jsx)(l.oz,{children:u}),(0,o.jsx)(l.oz,{children:m}),(0,o.jsx)(l.oz,{children:y}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'use orca_whirlpools::{\n  open_full_range_position_instructions, set_whirlpools_config_address, IncreaseLiquidityParam, WhirlpoolsConfigInput\n};\nuse solana_client::nonblocking::rpc_client::RpcClient;\nuse solana_sdk::pubkey::Pubkey;\nuse std::str::FromStr;\nuse solana_sdk::signature::Signer;\nuse orca_tx_sender::{\n    build_and_send_transaction,\n    set_rpc, get_rpc_client\n};\nuse solana_sdk::commitment_config::CommitmentLevel;\nuse crate::utils::load_wallet;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n  set_rpc("https://api.devnet.solana.com").await?;\n  set_whirlpools_config_address(WhirlpoolsConfigInput::SolanaDevnet).unwrap();\n  let wallet = load_wallet();\n  let whirlpool_address = Pubkey::from_str("3KBZiL2g8C7tiJ32hTv5v3KM7aK9htpqTw4cTXz1HvPt").unwrap();\n  let param = IncreaseLiquidityParam::TokenA(10);\n  let rpc = get_rpc_client()?;\n\n  let result = open_full_range_position_instructions(\n    &rpc,\n    whirlpool_address,\n    param,\n    Some(100),\n    Some(wallet.pubkey())\n  ).await?;\n\n  // The instructions include the position mint and potentially a new token \n  // account that needs to be created for WSOL.\n  let mut signers: Vec<&dyn Signer> = vec![&wallet];\n  signers.extend(result.additional_signers.iter().map(|kp| kp as &dyn Signer));\n  println!("Signers: {:?}", signers);\n\n  println!("Quote token mac B: {:?}", result.quote.token_max_b);\n  println!("Initialization cost: {:?}", result.initialization_cost);\n  println!("Position mint: {:?}", result.position_mint);\n  \n  let signature = build_and_send_transaction(\n      result.instructions,\n      &signers,\n      Some(CommitmentLevel::Confirmed),\n      None, // No address lookup tables\n  ).await?;\n  \n  println!("Transaction sent: {}", signature);\n  Ok(())\n}\n'})}),(0,o.jsx)(l.oz,{children:x}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'use orca_whirlpools::{\n  open_position_instructions, set_whirlpools_config_address, IncreaseLiquidityParam, WhirlpoolsConfigInput\n};\nuse solana_client::nonblocking::rpc_client::RpcClient;\nuse solana_sdk::pubkey::Pubkey;\nuse std::str::FromStr;\nuse solana_sdk::signature::Signer;\nuse orca_tx_sender::{\n    build_and_send_transaction,\n    set_rpc, get_rpc_client\n};\nuse solana_sdk::commitment_config::CommitmentLevel;\nuse crate::utils::load_wallet;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n  set_rpc("https://api.devnet.solana.com").await?;\n  set_whirlpools_config_address(WhirlpoolsConfigInput::SolanaDevnet).unwrap();\n  let wallet = load_wallet();\n  let whirlpool_address = Pubkey::from_str("3KBZiL2g8C7tiJ32hTv5v3KM7aK9htpqTw4cTXz1HvPt").unwrap();\n  let param = IncreaseLiquidityParam::TokenA(10);\n  let rpc = get_rpc_client()?;\n\n  let result = open_position_instructions(\n    &rpc,\n    whirlpool_address,\n    0.001,\n    100.0,\n    param,\n    Some(100),\n    Some(wallet.pubkey())\n  ).await?;\n\n  // The instructions include the position mint and potentially new token \n  // accounts that need to be created and signed for with their corresponding Keypair.\n  let mut signers: Vec<&dyn Signer> = vec![&wallet];\n  signers.extend(result.additional_signers.iter().map(|kp| kp as &dyn Signer));\n\n  println!("Quote token max B: {:?}", result.quote.token_est_b);\n  println!("Initialization cost: {:?}", result.initialization_cost);\n  println!("Position mint: {:?}", result.position_mint);\n  println!("Signers: {:?}", signers);\n\n  let signature = build_and_send_transaction(\n      result.instructions,\n      &signers,\n      Some(CommitmentLevel::Confirmed),\n      None, // No address lookup tables\n  ).await?;\n  \n  println!("Transaction sent: {}", signature);\n  Ok(())\n}\n'})}),(0,o.jsx)(l.oz,{children:w}),(0,o.jsx)(l.oz,{children:g}),(0,o.jsx)(l.oz,{children:f})]}),(0,o.jsxs)(r.A,{value:"typescript-kit",label:"TypeScript Kit",children:[(0,o.jsx)(l.oz,{children:h}),(0,o.jsx)(l.oz,{children:u}),(0,o.jsx)(l.oz,{children:m}),(0,o.jsx)(l.oz,{children:y}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import { openFullRangePosition, setWhirlpoolsConfig } from '@orca-so/whirlpools';\nimport { createSolanaRpc, devnet, address } from '@solana/kit';\nimport { loadWallet } from './utils';\n\nawait setWhirlpoolsConfig('solanaDevnet');\nconst devnetRpc = createSolanaRpc(devnet('https://api.devnet.solana.com'));\nconst wallet = await loadWallet(); // load your wallet\n\nconst whirlpoolAddress = address(\"3KBZiL2g8C7tiJ32hTv5v3KM7aK9htpqTw4cTXz1HvPt\"); // SOL/devUSDC\n\nconst param = { tokenA: 10n };\n\nconst { quote, instructions, initializationCost, positionMint, callback: sendTx } = await openFullRangePosition(\n  devnetRpc,\n  whirlpoolAddress,\n  param,\n  100,\n  wallet\n);\n\n// Use the callback to submit the transaction\nconst txId = await sendTx();\n\nconsole.log(`Quote token max B: ${quote.tokenMaxB}`);\nconsole.log(`Initialization cost: ${initializationCost}`);\nconsole.log(`Position mint: ${positionMint}`);\nconsole.log(`Transaction ID: ${txId}`);\n"})}),(0,o.jsx)(l.oz,{children:x}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import { openPosition, setWhirlpoolsConfig } from '@orca-so/whirlpools';\nimport { createSolanaRpc, devnet, address, setRpc, setPayerFromBytes } from '@solana/kit';\nimport secret from \"wallet.json\";\n\nawait setWhirlpoolsConfig('solanaDevnet');\nawait setRpc('https://api.devnet.solana.com');\nconst signer = await setPayerFromBytes(new Uint8Array(secret));\n\nconst whirlpoolAddress = address(\"3KBZiL2g8C7tiJ32hTv5v3KM7aK9htpqTw4cTXz1HvPt\"); // SOL/devUSDC\n\nconst param = { tokenA: 10n };\n\nconst { quote, instructions, initializationCost, positionMint, callback: sendTx } = await openPosition(\n  devnetRpc,\n  whirlpoolAddress,\n  param,\n  0.001,\n  100.0,\n  100,\n  wallet\n  );\n\n// Use the callback to submit the transaction\nconst txId = await sendTx();\n\nconsole.log(`Quote token max B: ${quote.tokenEstB}`);\nconsole.log(`Initialization cost: ${initializationCost}`);\nconsole.log(`Position mint: ${positionMint}`);\nconsole.log(`Transaction ID: ${txId}`);\n"})}),(0,o.jsx)(l.oz,{children:w}),(0,o.jsx)(l.oz,{children:g}),(0,o.jsx)(l.oz,{children:f})]}),(0,o.jsxs)(r.A,{value:"typescript-legacy",label:"TypeScript Legacy",children:[(0,o.jsx)(n.p,{children:"Positions in Whirlpools are tracked with a minted NFT in the user's wallet."}),(0,o.jsx)(n.p,{children:"The usual action of opening a position consists of two instruction calls"}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"initializeTickArray"})," to initialize the tick arrays that would host your desired ticks for your position if they do not exist yet."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Whirlpool.openPosition"})," or ",(0,o.jsx)(n.code,{children:"Whirlpool.openPositionWithMetadata"})," to mint the position and define the tick range"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"increaseLiquidity"})," to transfer tokens from your wallet into a position."]}),"\n"]}),(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"Whirlpool.openPosition"})," function now supports both traditional and Token2022-based position NFTs. To utilize Token2022, provide the Token2022 ProgramId as the ",(0,o.jsx)(n.code,{children:"tokenProgramId"})," parameter when calling ",(0,o.jsx)(n.code,{children:"openPosition"}),". This will mint the NFT using Token2022, which leverages the MetadataPointer and TokenMetadata extensions, eliminating the need for Metaplex metadata accounts."]}),(0,o.jsx)(n.h2,{id:"opening-position-with-metadata",children:"Opening Position with Metadata"}),(0,o.jsxs)(n.p,{children:["By using ",(0,o.jsx)(n.code,{children:"Whirlpool.openPositionWithMetadata"}),", users have the option of appending ",(0,o.jsx)(n.a,{href:"https://www.metaplex.com/learn-developers",children:"Metaplex metadata"})," onto the Token Program position NFT. Doing so will allow the token to be identifiable in tracking websites or wallets as a Whirlpool NFT. The drawback is it will require more compute-budget and will incurr Metaplex fees of 0.01 SOL."]}),(0,o.jsx)(n.h2,{id:"initialize-tick-array-accounts-if-needed",children:"Initialize Tick Array accounts if needed"}),(0,o.jsxs)(n.p,{children:["For liquidity to exist in the Whirlpool, the tick-array that contains that particular tick must be initialized. Calculate the start_index of the required tick array and use the ",(0,o.jsx)(n.code,{children:"initialize_tick_array"})," instruction to initialize it."]}),(0,o.jsxs)(n.p,{children:["More often than not, tick-arrays are already created. But if you want your code to be defensive, you should do a check prior to invoking ",(0,o.jsx)(n.code,{children:"open_position"}),". To understand more on how Tick-Arrays work in Whirlpools, read here."]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"const tickArrayPda = PDAUtil.getTickArray(\n  this.ctx.program.programId,\n  this.address,\n  startTick\n);\n\n// Check if tick array exists\nconst fetcher = new AccountFetcher(...);\nconst ta = await fetcher.getTickArray(tickArrayPda.publicKey, true);\n// Exit if it exists\nif (!!ta) {\n  return;\n}\n\n// Construct Init Tick Array Ix\nconst tx = toTx(ctx, WhirlpoolIx.initTickArrayIx(this.ctx.program, {\n  startTick,\n  tickArrayPda,\n  whirlpool: this.address,\n  funder: !!funder ? AddressUtil.toPubKey(funder) : this.ctx.wallet.publicKey,\n}));\nawait tx.buildAndExecute();\n"})}),(0,o.jsx)(n.h2,{id:"open-position-with-whirlpoolclient",children:"Open Position with WhirlpoolClient"}),(0,o.jsxs)(n.p,{children:["WhirlpoolClient's ",(0,o.jsx)(n.code,{children:"openPosition"})," method bundles the open and increase liquidity instructions into a single transaction for you. Below is a code sample to create a position for the SOL/USDC pool at the price between ",(0,o.jsxs)(n.span,{className:"katex",children:[(0,o.jsx)(n.span,{className:"katex-mathml",children:(0,o.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,o.jsxs)(n.semantics,{children:[(0,o.jsxs)(n.mrow,{children:[(0,o.jsx)(n.mn,{children:"98"}),(0,o.jsx)(n.mo,{children:"\u2212"})]}),(0,o.jsx)(n.annotation,{encoding:"application/x-tex",children:"98 - "})]})})}),(0,o.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,o.jsxs)(n.span,{className:"base",children:[(0,o.jsx)(n.span,{className:"strut",style:{height:"0.7278em",verticalAlign:"-0.0833em"}}),(0,o.jsx)(n.span,{className:"mord",children:"98"}),(0,o.jsx)(n.span,{className:"mord",children:"\u2212"})]})})]}),"150, with the intention to deposit 50 SOL into the position."]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"// Derive the Whirlpool address\nconst poolAddress = PDAUtil.getWhirlpool(\n  WHIRLPOOL_PROGRAM_ID,\n  ORCA_WHIRLPOOLS_CONFIG,\n  SOL_MINT,\n  USDC_MINT,\n  64\n);\n\n// Load everything that you need\nconst client = buildWhirlpoolClient(context, fetcher);\nconst pool = await client.getPool(poolAddress.publicKey);\nconst poolData = pool.getData();\nconst poolTokenAInfo = pool.getTokenAInfo();\nconst poolTokenBInfo = pool.getTokenBInfo();\n\n// Derive the tick-indices based on a human-readable price\nconst tokenADecimal = poolTokenAInfo.decimals;\nconst tokenBDecimal = poolTokenBInfo.decimals;\nconst tickLower = TickUtil.getInitializableTickIndex(\n  PriceMath.priceToTickIndex(new Decimal(98), tokenADecimal, tokenBDecimal),\n  poolData.tickSpacing\n);\nconst tickUpper = TickUtil.getInitializableTickIndex(\n  PriceMath.priceToTickIndex(new Decimal(150), tokenADecimal, tokenBDecimal),\n  poolData.tickSpacing\n);\n\n// Get a quote on the estimated liquidity and tokenIn (50 tokenA)\nconst quote = increaseLiquidityQuoteByInputToken(\n  poolTokenAInfo.mint,\n  new Decimal(50),\n  tickLower,\n  tickUpper,\n  Percentage.fromFraction(1, 100),\n  pool\n);\n\n// Evaluate the quote if you need\nconst {tokenMaxA, tokenMaxB} = quote\n\n// Construct the open position & increase_liquidity ix and execute the transaction.\nconst { positionMint, tx } = await pool.openPosition(\n  lowerTick,\n  upperTick,\n  quote\n);\nconst txId = await tx.buildAndExecute();\n\n// Fetch the newly created position with liquidity\nconst position = await client.getPosition(\n  PDAUtil.getPosition(WHIRLPOOL_PROGRAM_ID, positionMint).publicKey\n)\n"})}),(0,o.jsx)(n.h2,{id:"the-manual-way",children:"The Manual way"}),(0,o.jsxs)(n.p,{children:["Follow the instructions below if you would like to have more control over your instruction building process. Note that ",(0,o.jsx)(n.code,{children:"open_position"}),' does not add liquidity to a position. Follow the next article "Modify Liquidity" to add liquidity.']}),(0,o.jsx)(n.h2,{id:"determine-position-parameters",children:"Determine position parameters"}),(0,o.jsxs)(n.p,{children:["To open a position against a Whirlpool, you must first define certain parameters of your position to invoke the ",(0,o.jsx)(n.code,{children:"open_position"})," instruction."]}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"WhirlpoolKey"})," - The public key for the Whirlpool that the position will host liquidity in."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"tickLowerIndex"}),", ",(0,o.jsx)(n.code,{children:"tickUpperIndex"})," - The tick index bounds for the position. Must be an initializable index."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"positionMintAddress"})," - A generated empty Keypair that will be initialized to a token mint."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"positionPda"})," -  Derived address of the position account via ",(0,o.jsx)(n.code,{children:"getPositionPda"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"positionTokenAccountAddress"})," - This is the account that will hold the minted position token. It is the associated token address of the position-mint."]}),"\n"]}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"const positionMintKeypair = Keypair.generate();\nconst positionPda = getPositionPda(programId, positionMintKeypair.publicKey);\nconst metadataPda = getPositionMetadataPda(positionMintKeypair.publicKey);\nconst positionTokenAccountAddress = await deriveATA(\n  provider.wallet.publicKey,\n  positionMintKeypair.publicKey\n);\n\nconst positionIx = toTx(ctx, WhirlpoolIx.openPositionWithMetadataIx(ctx.program, {\n  funder: provider.wallet.publicKey,\n  ownerKey: provider.wallet.publicKey,\n  positionPda,\n  metadataPda,\n  positionMintAddress: positionMintKeypair.publicKey,\n  positionTokenAccountAddress,\n  whirlpoolKey: toPubKey(poolAddress),\n  tickLowerIndex,\n  tickUpperIndex,\n})).addSigner(positionMintKeypair).buildAndExecute();\n"})}),(0,o.jsx)(n.p,{children:"Once your position is open, proceed to the next section to add liquidity."}),(0,o.jsx)(n.h2,{id:"common-errors",children:"Common Errors"}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"InvalidTickIndex"})," (0x177a)","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"tickLowerIndex is higher than upper tickUpperIndex"}),"\n",(0,o.jsxs)(n.li,{children:["Some tick indices is not an initializable index (not a multiple of tickSpacing). Use ",(0,o.jsx)(n.code,{children:"TickUtil.getInitializableTickIndex"})," to get the closest initializable tick to your index."]}),"\n",(0,o.jsx)(n.li,{children:"Some tick indices is out of bounds"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"NotRentExempt"})," (0x0)","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Usually, the TickArray that houses your tickLowerIndex or tickUpperIndex has not been initialized. Use the ",(0,o.jsx)(n.code,{children:"WhirlpoolClient.initTickArrayForTicks"})," or ",(0,o.jsx)(n.code,{children:"WhirlpoolIx.initTickArrayIx"})," to initialize the array at the derived startTickIndex."]}),"\n",(0,o.jsxs)(n.li,{children:["Alternatively, if this failure is from ",(0,o.jsx)(n.code,{children:"init_tick_array"}),", the tick array has already been initialized."]}),"\n"]}),"\n"]}),"\n"]})]})]})]})}function v(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(P,{...e})}):P(e)}}}]);