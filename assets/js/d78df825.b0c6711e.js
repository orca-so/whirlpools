"use strict";(self.webpackChunk_orca_so_whirlpools_docs=self.webpackChunk_orca_so_whirlpools_docs||[]).push([[305],{5826:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>d,default:()=>x,frontMatter:()=>c,introText:()=>u,metadata:()=>o,nextStepsText:()=>f,overviewText:()=>h,startingGuideText:()=>w,toc:()=>y,usageExampleText:()=>g});const o=JSON.parse('{"id":"SDKs/Position Management/Harvest","title":"Harvest","description":"With this function, you can:","source":"@site/docs/03-SDKs/04-Position Management/03-Harvest.mdx","sourceDirName":"03-SDKs/04-Position Management","slug":"/SDKs/Position Management/Harvest","permalink":"/SDKs/Position Management/Harvest","draft":false,"unlisted":false,"editUrl":"https://github.com/orca-so/whirlpools/tree/main/docs/whirlpool/docs/03-SDKs/04-Position Management/03-Harvest.mdx","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_label":"Harvest","hide_table_of_contents":true},"sidebar":"sidebar","previous":{"title":"Adjust Liquidity","permalink":"/SDKs/Position Management/Adjust Liquidity"},"next":{"title":"Close Position","permalink":"/SDKs/Position Management/Close Position"}}');var i=n(1085),s=n(1184),r=n(95),a=n(4435),l=n(8156);const c={sidebar_label:"Harvest",hide_table_of_contents:!0},d="Harvesting a Position",p={},u="\nHarvesting a position in Orca Whirlpools allows you to collect any accumulated fees and rewards without closing the position. This process is useful when you want to claim your earnings while keeping your liquidity active in the pool, ensuring you continue to benefit from potential future fees.\n",h="\n## 1. Overview of Harvesting a Position\nThe SDK helps you generate the instructions needed to collect fees and rewards from a position without closing it. This allows you to realize your earnings while maintaining liquidity in the pool.\n\nWith this function, you can:\n- Collect accumulated trading fees from your position.\n- Harvest rewards earned by providing liquidity, all while keeping the position active.\n",w="\n## 2. Getting Started Guide\n### Step-by-Step Guide to Harvesting a Position\nTo harvest fees and rewards from a position, follow these steps:\n1. **RPC Client**: Use a Solana RPC client to interact with the blockchain.\n2. **Position Mint**: Provide the mint address of the NFT representing your position. This NFT serves as proof of ownership and represents the liquidity in the position.\n3. **Authority**: This can be your wallet, which will fund the pool initialization. If the authority is not specified, the default wallet will be used. You can configure the default wallet through the SDK.\n4. **Create Instructions**: Use the appropriate function to generate the necessary instructions to harvest fees and rewards.\n",g="\n## 3. Usage Example\nSuppose you are a developer creating a bot to manage investments for a group of investors. The bot periodically collects accumulated fees and rewards from liquidity positions to distribute profits among investors. By using the SDK, you can generate the instructions to collect earnings from each active position without closing it, allowing the liquidity to continue generating returns and potentially reinvest your earned fees into the position.\n",f="\n## 4. Next Steps\nAfter harvesting fees and rewards, you can:\n\n- [Monitor Performance](02-Fetch%20Positions.mdx): Keep track of your position to evaluate future earnings and the overall performance.\n- Reinvest Earnings: Use the harvested fees and rewards to add more liquidity or diversify your positions.\n- Harvest Regularly: Regularly collect your earnings to maintain optimal capital efficiency while keeping your liquidity active.\n\nBy using the SDK, you can maximize the benefits of providing liquidity while keeping your position open and continuously earning fees.\n",y=[{value:"Get a quick quote on outstanding fees and rewards",id:"get-a-quick-quote-on-outstanding-fees-and-rewards",level:2},{value:"Update on-chain position with the latest accrued fees",id:"update-on-chain-position-with-the-latest-accrued-fees",level:2},{value:"Collect Fees and Rewards",id:"collect-fees-and-rewards",level:2},{value:"Collect fee",id:"collect-fee",level:3},{value:"Collect rewards",id:"collect-rewards",level:3}];function m(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"harvesting-a-position",children:"Harvesting a Position"})}),"\n",(0,i.jsxs)(r.A,{groupId:"sdk-type",children:[(0,i.jsxs)(a.A,{value:"rust",label:"Rust",children:[(0,i.jsx)(l.oz,{children:u}),(0,i.jsx)(l.oz,{children:h}),(0,i.jsx)(l.oz,{children:w}),(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:'use orca_whirlpools::{\n    harvest_position_instructions, set_whirlpools_config_address, WhirlpoolsConfigInput,\n};\nuse solana_client::nonblocking::rpc_client::RpcClient;\nuse solana_sdk::pubkey::Pubkey;\nuse std::str::FromStr;\nuse solana_sdk::signature::Signer;\nuse orca_tx_sender::{\n    build_and_send_transaction,\n    set_rpc, get_rpc_client\n};\nuse solana_sdk::commitment_config::CommitmentLevel;\nuse crate::utils::load_wallet;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    set_rpc("https://api.devnet.solana.com").await?;\n    set_whirlpools_config_address(WhirlpoolsConfigInput::SolanaDevnet).unwrap();\n    let wallet = load_wallet();\n    let rpc = get_rpc_client()?;\n\n    let position_mint_address =\n        Pubkey::from_str("HqoV7Qv27REUtmd9UKSJGGmCRNx3531t33bDG1BUfo9K").unwrap();\n\n    let result = harvest_position_instructions(&rpc, position_mint_address, Some(wallet.pubkey()))\n        .await?;\n\n    // The instructions may include new token accounts that need to be created\n    // and signed for with their corresponding Keypair.\n    let mut signers: Vec<&dyn Signer> = vec![&wallet];\n    signers.extend(result.additional_signers.iter().map(|kp| kp as &dyn Signer));\n\n    println!("Fees Quote: {:?}", result.fees_quote);\n    println!("Rewards Quote: {:?}", result.rewards_quote);\n    println!("Number of Instructions: {}", result.instructions.len());\n    println!("Signers: {:?}", signers);\n    \n    let signature = build_and_send_transaction(\n        result.instructions,\n        &signers,\n        Some(CommitmentLevel::Confirmed),\n        None, // No address lookup tables\n    ).await?;\n    \n    println!("Harvest transaction sent: {}", signature);\n    Ok(())\n}\n'})}),(0,i.jsx)(l.oz,{children:g}),(0,i.jsx)(l.oz,{children:f})]}),(0,i.jsxs)(a.A,{value:"typescript-kit",label:"TypeScript Kit",children:[(0,i.jsx)(l.oz,{children:u}),(0,i.jsx)(l.oz,{children:h}),(0,i.jsx)(l.oz,{children:w}),(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",children:"import { harvestPosition, setWhirlpoolsConfig } from '@orca-so/whirlpools';\nimport { createSolanaRpc, devnet, address, setRpc, setPayerFromBytes } from '@solana/kit';\nimport secret from \"wallet.json\";\n\nawait setWhirlpoolsConfig('solanaDevnet');\nawait setRpc('https://api.devnet.solana.com');\nconst signer = await setPayerFromBytes(new Uint8Array(secret));\nconst positionMint = address(\"HqoV7Qv27REUtmd9UKSJGGmCRNx3531t33bDG1BUfo9K\");\n\nconst { feesQuote, rewardsQuote, instructions, callback: sendTx } = await harvestPosition(\n  devnetRpc,\n  positionMint,\n  signer\n);\n\n// Use the callback to submit the transaction\nconst txId = await sendTx();\n\nconsole.log(`Fees owed token A: ${feesQuote.feeOwedA}`);\nconsole.log(`Rewards '1' owed: ${rewardsQuote.rewards[0].rewardsOwed}`);\nconsole.log(`Transaction ID: ${txId}`);\n"})}),(0,i.jsx)(l.oz,{children:g}),(0,i.jsx)(l.oz,{children:f})]}),(0,i.jsxs)(a.A,{value:"typescript-legacy",label:"TypeScript Legacy",children:[(0,i.jsx)(t.p,{children:"As the liquidity pool is traded upon, liquidity providers will begin to accrue fees and rewards. Follow the following steps to see how much you are owe and how to collect them."}),(0,i.jsx)(t.h2,{id:"get-a-quick-quote-on-outstanding-fees-and-rewards",children:"Get a quick quote on outstanding fees and rewards"}),(0,i.jsxs)(t.p,{children:["There are use-cases where users would like to check the outstanding values before deciding to perform an on-chain update and harvest. In these cases, use the provided ",(0,i.jsx)(t.code,{children:"collectFeesQuote"})," and ",(0,i.jsx)(t.code,{children:"collectRewardsQuote"})," in the Typescript SDK."]}),(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",children:"// Fetching necessary on-chain account data.\nconst whirlpool = await fetcher.getPool(whirlpoolAddress);\nconst position = await fetcher.getPosition(positionAddress)\n// Fetching tick array. Note that you may have to fetch two of them\n// if the upper and lower ticks live on different tick arrays.\nconst tickArrayAddress = TickUtil.getPdaWithTickIndex(tickLowerIndex, ...);\nconst tickArray = await fetcher.getTickArray(tickArrayAddress);\n\n// Get the individual TickData on each tickIndex from the fetched TickArray\nconst lowerTick = TickUtil.getTickFromTickArrayData(tickArrayData, tickLowerIndex, tickSpacing);\nconst upperTick = TickUtil.getTickFromTickArrayData(tickArrayData, tickUpperIndex, tickSpacing);\n\nconst feeQuote = collectFeesQuote({\n  whirlpool,\n  position,\n  tickLower: lowerTick,\n  tickUpper: upperTick,\n});\n\nconst feesInTokenA = feeQuote.feeOwedA;\nconst feesInTokenB = feeQuote.feeOwedB;\n\nconst rewardQuote = collectRewardsQuote({\n  whirlpool,\n  position,\n  tickLower: lowerTick,\n  tickUpper: upperTick,\n});\n\nconst rewardsInReward0 = rewardQuote[0].toNumber();\nconst rewardsInReward1 = rewardQuote[1].toNumber();\nconst rewardsInReward2 = rewardQuote[2].toNumber();\n"})}),(0,i.jsx)(t.h2,{id:"update-on-chain-position-with-the-latest-accrued-fees",children:"Update on-chain position with the latest accrued fees"}),(0,i.jsxs)(t.p,{children:["Before you fetch your owed fees, you must update the on-chain position with the latest values by calling ",(0,i.jsx)(t.code,{children:"increase_liquidity"})," or ",(0,i.jsx)(t.code,{children:"decrease_liquidity"}),". Alternatively, you can call ",(0,i.jsx)(t.code,{children:"update_fee_and_rewards"})," to update without modifying liquidity."]}),(0,i.jsx)(t.p,{children:"If this step is skipped, the collect instructions will only fetch the last updated values of the position. In many cases, this will be 0."}),(0,i.jsxs)(t.p,{children:["Sample code on using ",(0,i.jsx)(t.code,{children:"update_fee_and_rewards"}),":"]}),(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",children:"const whirlpool = await fetcher.getPool(whirlpoolAddress);\nconst position = await fetcher.getPosition(positionAddress);\nconst tickArrayLower = getTickArrayPda(ctx.program.programId, whirlpoolAddress, position.tickLowerIndex);\nconst tickArrayUpper = getTickArrayPda(ctx.program.programId, whirlpoolAddress, position.tickUpperIndex);\nawait toTx(ctx, WhirlpoolIx.updateFeesAndRewardsIx(ctx.program, {\n    whirlpool: position.whirlpool,\n    position: positionAddress,\n    tickArrayLower,\n    tickArrayUpper,\n})).buildAndExecute();\n"})}),(0,i.jsx)(t.h2,{id:"collect-fees-and-rewards",children:"Collect Fees and Rewards"}),(0,i.jsxs)(t.p,{children:["Once the position has been updated, you can use ",(0,i.jsx)(t.code,{children:"collect_fees"})," and ",(0,i.jsx)(t.code,{children:"collect_reward"})," to harvest the position."]}),(0,i.jsx)(t.h3,{id:"collect-fee",children:"Collect fee"}),(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",children:"const whirlpool = await fetcher.getPool(whirlpoolAddress);\nconst position = await fetcher.getPosition(positionAddress);\n\nconst positionTokenAccount = await deriveATA(provider.wallet.publicKey, position.positionMint);\nconst tokenOwnerAccountA = await deriveATA(provider.wallet.publicKey, whirlpool.tokenMintA);\nconst tokenOwnerAccountB = await deriveATA(provider.wallet.publicKey, whirlpool.tokenMintB);\n\nawait toTx(ctx, WhirlpoolIx.collectFeesIx(ctx.program, {\n  whirlpool: whirlpoolAddress,\n  positionAuthority: provider.wallet.publicKey,\n  position: positionAddress,\n  positionTokenAccount,\n  tokenOwnerAccountA,\n  tokenOwnerAccountB,\n  tokenVaultA: whirlpool.tokenVaultA,\n  tokenVaultB: whirlpool.tokenVaultB\n})).buildAndExecute();\n"})}),(0,i.jsx)(t.h3,{id:"collect-rewards",children:"Collect rewards"}),(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",children:"// Fetching rewards at reward index 0\nconst whirlpool = await fetcher.getPool(whirlpoolAddress);\nconst position = await fetcher.getPosition(positionAddress);\n\nconst rewardTokenMint = whirlpool.rewardInfos[0].mint;\nconst rewardOwnerAccount = await deriveATA(provider.wallet.publicKey, rewardTokenMint);\nconst positionTokenAccount = await deriveATA(provider.wallet.publicKey, position.positionMint);\n\nawait toTx(ctx, WhirlpoolIx.collectRewardIx(ctx.program, {\n  whirlpool: whirlpoolAddress,\n  positionAuthority: provider.wallet.publicKey,\n  position: positionAddress,\n  positionTokenAccount,\n  rewardOwnerAccount: rewardOwnerAccount,\n  rewardVault: whirlpool.rewardInfo[0].vault,\n  rewardIndex: 0,\n})).buildAndExecute();\n"})})]})]})]})}function x(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(m,{...e})}):m(e)}}}]);