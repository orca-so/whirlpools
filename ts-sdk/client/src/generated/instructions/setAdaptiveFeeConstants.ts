/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getOptionDecoder,
  getOptionEncoder,
  getStructDecoder,
  getStructEncoder,
  getU16Decoder,
  getU16Encoder,
  getU32Decoder,
  getU32Encoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type Option,
  type OptionOrNullable,
  type ReadonlyAccount,
  type ReadonlySignerAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
} from "@solana/kit";
import { WHIRLPOOL_PROGRAM_ADDRESS } from "../programs";
import { getAccountMetaFactory, type ResolvedAccount } from "../shared";

export const SET_ADAPTIVE_FEE_CONSTANTS_DISCRIMINATOR = new Uint8Array([
  133, 158, 212, 189, 237, 12, 73, 39,
]);

export function getSetAdaptiveFeeConstantsDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    SET_ADAPTIVE_FEE_CONSTANTS_DISCRIMINATOR,
  );
}

export type SetAdaptiveFeeConstantsInstruction<
  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,
  TAccountWhirlpool extends string | AccountMeta<string> = string,
  TAccountWhirlpoolsConfig extends string | AccountMeta<string> = string,
  TAccountOracle extends string | AccountMeta<string> = string,
  TAccountFeeAuthority extends string | AccountMeta<string> = string,
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountWhirlpool extends string
        ? ReadonlyAccount<TAccountWhirlpool>
        : TAccountWhirlpool,
      TAccountWhirlpoolsConfig extends string
        ? ReadonlyAccount<TAccountWhirlpoolsConfig>
        : TAccountWhirlpoolsConfig,
      TAccountOracle extends string
        ? WritableAccount<TAccountOracle>
        : TAccountOracle,
      TAccountFeeAuthority extends string
        ? ReadonlySignerAccount<TAccountFeeAuthority> &
            AccountSignerMeta<TAccountFeeAuthority>
        : TAccountFeeAuthority,
      ...TRemainingAccounts,
    ]
  >;

export type SetAdaptiveFeeConstantsInstructionData = {
  discriminator: ReadonlyUint8Array;
  filterPeriod: Option<number>;
  decayPeriod: Option<number>;
  reductionFactor: Option<number>;
  adaptiveFeeControlFactor: Option<number>;
  maxVolatilityAccumulator: Option<number>;
  tickGroupSize: Option<number>;
  majorSwapThresholdTicks: Option<number>;
};

export type SetAdaptiveFeeConstantsInstructionDataArgs = {
  filterPeriod: OptionOrNullable<number>;
  decayPeriod: OptionOrNullable<number>;
  reductionFactor: OptionOrNullable<number>;
  adaptiveFeeControlFactor: OptionOrNullable<number>;
  maxVolatilityAccumulator: OptionOrNullable<number>;
  tickGroupSize: OptionOrNullable<number>;
  majorSwapThresholdTicks: OptionOrNullable<number>;
};

export function getSetAdaptiveFeeConstantsInstructionDataEncoder(): Encoder<SetAdaptiveFeeConstantsInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
      ["filterPeriod", getOptionEncoder(getU16Encoder())],
      ["decayPeriod", getOptionEncoder(getU16Encoder())],
      ["reductionFactor", getOptionEncoder(getU16Encoder())],
      ["adaptiveFeeControlFactor", getOptionEncoder(getU32Encoder())],
      ["maxVolatilityAccumulator", getOptionEncoder(getU32Encoder())],
      ["tickGroupSize", getOptionEncoder(getU16Encoder())],
      ["majorSwapThresholdTicks", getOptionEncoder(getU16Encoder())],
    ]),
    (value) => ({
      ...value,
      discriminator: SET_ADAPTIVE_FEE_CONSTANTS_DISCRIMINATOR,
    }),
  );
}

export function getSetAdaptiveFeeConstantsInstructionDataDecoder(): Decoder<SetAdaptiveFeeConstantsInstructionData> {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["filterPeriod", getOptionDecoder(getU16Decoder())],
    ["decayPeriod", getOptionDecoder(getU16Decoder())],
    ["reductionFactor", getOptionDecoder(getU16Decoder())],
    ["adaptiveFeeControlFactor", getOptionDecoder(getU32Decoder())],
    ["maxVolatilityAccumulator", getOptionDecoder(getU32Decoder())],
    ["tickGroupSize", getOptionDecoder(getU16Decoder())],
    ["majorSwapThresholdTicks", getOptionDecoder(getU16Decoder())],
  ]);
}

export function getSetAdaptiveFeeConstantsInstructionDataCodec(): Codec<
  SetAdaptiveFeeConstantsInstructionDataArgs,
  SetAdaptiveFeeConstantsInstructionData
> {
  return combineCodec(
    getSetAdaptiveFeeConstantsInstructionDataEncoder(),
    getSetAdaptiveFeeConstantsInstructionDataDecoder(),
  );
}

export type SetAdaptiveFeeConstantsInput<
  TAccountWhirlpool extends string = string,
  TAccountWhirlpoolsConfig extends string = string,
  TAccountOracle extends string = string,
  TAccountFeeAuthority extends string = string,
> = {
  whirlpool: Address<TAccountWhirlpool>;
  whirlpoolsConfig: Address<TAccountWhirlpoolsConfig>;
  oracle: Address<TAccountOracle>;
  feeAuthority: TransactionSigner<TAccountFeeAuthority>;
  filterPeriod: SetAdaptiveFeeConstantsInstructionDataArgs["filterPeriod"];
  decayPeriod: SetAdaptiveFeeConstantsInstructionDataArgs["decayPeriod"];
  reductionFactor: SetAdaptiveFeeConstantsInstructionDataArgs["reductionFactor"];
  adaptiveFeeControlFactor: SetAdaptiveFeeConstantsInstructionDataArgs["adaptiveFeeControlFactor"];
  maxVolatilityAccumulator: SetAdaptiveFeeConstantsInstructionDataArgs["maxVolatilityAccumulator"];
  tickGroupSize: SetAdaptiveFeeConstantsInstructionDataArgs["tickGroupSize"];
  majorSwapThresholdTicks: SetAdaptiveFeeConstantsInstructionDataArgs["majorSwapThresholdTicks"];
};

export function getSetAdaptiveFeeConstantsInstruction<
  TAccountWhirlpool extends string,
  TAccountWhirlpoolsConfig extends string,
  TAccountOracle extends string,
  TAccountFeeAuthority extends string,
  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,
>(
  input: SetAdaptiveFeeConstantsInput<
    TAccountWhirlpool,
    TAccountWhirlpoolsConfig,
    TAccountOracle,
    TAccountFeeAuthority
  >,
  config?: { programAddress?: TProgramAddress },
): SetAdaptiveFeeConstantsInstruction<
  TProgramAddress,
  TAccountWhirlpool,
  TAccountWhirlpoolsConfig,
  TAccountOracle,
  TAccountFeeAuthority
> {
  // Program address.
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false,
    },
    oracle: { value: input.oracle ?? null, isWritable: true },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.oracle),
      getAccountMeta(accounts.feeAuthority),
    ],
    data: getSetAdaptiveFeeConstantsInstructionDataEncoder().encode(
      args as SetAdaptiveFeeConstantsInstructionDataArgs,
    ),
    programAddress,
  } as SetAdaptiveFeeConstantsInstruction<
    TProgramAddress,
    TAccountWhirlpool,
    TAccountWhirlpoolsConfig,
    TAccountOracle,
    TAccountFeeAuthority
  >);
}

export type ParsedSetAdaptiveFeeConstantsInstruction<
  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    whirlpool: TAccountMetas[0];
    whirlpoolsConfig: TAccountMetas[1];
    oracle: TAccountMetas[2];
    feeAuthority: TAccountMetas[3];
  };
  data: SetAdaptiveFeeConstantsInstructionData;
};

export function parseSetAdaptiveFeeConstantsInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>,
): ParsedSetAdaptiveFeeConstantsInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 4) {
    // TODO: Coded error.
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      whirlpoolsConfig: getNextAccount(),
      oracle: getNextAccount(),
      feeAuthority: getNextAccount(),
    },
    data: getSetAdaptiveFeeConstantsInstructionDataDecoder().decode(
      instruction.data,
    ),
  };
}
